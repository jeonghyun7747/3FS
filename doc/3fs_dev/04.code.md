
# perror를 사용는 이유는 

좋은 질문입니다. `perror()`와 `printf()`는 출력이라는 점에서는 비슷해 보이지만, **에러 출력 상황에서는 매우 다른 목적과 기능**을 갖고 있습니다.

---

## ✅ `perror()`를 사용하는 이유

```c
perror("write");
```

이 함수는 다음을 자동으로 해줍니다:

1. **인자로 전달한 문자열 ("write")을 출력하고**
2. **직전에 실패한 시스템 콜의 원인을 `errno`를 이용해 설명하는 에러 메시지를 출력**합니다.

예를 들어 `write()`가 실패하고 `errno`가 `EACCES`일 경우, 다음과 같은 출력이 됩니다:

```
write: Permission denied
```

---

## ⚠️ `printf()`로 같은 내용을 출력하려면?

```c
#include <string.h>
#include <errno.h>

printf("write: %s\n", strerror(errno));
```

위처럼 `errno` 값을 직접 `strerror()`에 넘겨야 하고, 코드가 더 복잡해집니다.

---

## 🔍 정리: `perror()` vs `printf()`

| 항목                  | `perror()` | `printf()`                    |
| ------------------- | ---------- | ----------------------------- |
| 에러 메시지 자동 출력        | ✅          | ❌ 직접 `strerror(errno)` 사용해야 함 |
| 간결한 코드              | ✅          | ❌ 더 복잡                        |
| 에러 상황에 특화           | ✅          | ❌                             |
| 표준 오류 (`stderr`) 출력 | ✅          | ❌ 기본은 표준 출력(`stdout`)         |

---

## ✅ 결론

`perror()`는 시스템 호출(`open`, `write`, `read` 등)이 실패했을 때 발생한 **에러의 원인을 자동으로 설명해 주는 함수**입니다.
따라서 시스템 수준 오류 처리에는 `printf()`보다 **`perror()`를 쓰는 것이 표준적이고 안전한 방법**입니다.

필요하다면 `strerror()`를 이용한 사용자 정의 메시지도 알려드릴 수 있습니다.


# 디버깅을 위한 출력 방법은

디버깅 목적으로 **중간 진행 상태를 출력**하고 싶을 때, 상황에 따라 다음과 같은 방법 중에서 선택하는 것이 가장 좋습니다.

---

## ✅ 1. **`printf()` 사용** – 가장 간단한 방법

디버깅용으로 가장 직관적이고 빠르게 사용할 수 있습니다.

```c
printf("파일 열기 시도 중...\n");
```

### ✅ 장점

* 사용 간단
* 어디서나 쓸 수 있음

### ⚠️ 단점

* 로그 수준 없음 (info, error, debug 구분 안 됨)
* 나중에 지우기 어렵거나 놓치기 쉬움

---

## ✅ 2. **`fprintf(stderr, ...)` 사용** – 경고/에러 메시지 출력에 적합

```c
fprintf(stderr, "경고: 파일 권한이 이상합니다\n");
```

### ✅ 장점

* `stderr`는 `stdout`과 분리되어 있어 에러 메시지 추적에 용이
* 리디렉션 시 `stderr`를 별도로 저장 가능

---

## ✅ 3. **매크로를 활용한 디버깅 메시지 제어**

```c
#define DEBUG 1

#if DEBUG
    #define DBG_PRINT(fmt, ...) fprintf(stderr, "DEBUG: " fmt, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...) // no-op
#endif
```

사용 예:

```c
DBG_PRINT("파일 디스크립터: %d\n", fd);
```

### ✅ 장점

* 디버깅 출력과 일반 출력 구분
* `DEBUG` 플래그로 컴파일 시 제어 가능 (`gcc -DDEBUG=1`)
* 나중에 제거하지 않아도 디버깅 메시지를 쉽게 끄고 켤 수 있음

---

## ✅ 4. **`syslog()` 사용** – 시스템 로그에 기록

```c
#include <syslog.h>

openlog("myapp", LOG_PID | LOG_CONS, LOG_USER);
syslog(LOG_INFO, "작업 시작");
syslog(LOG_ERR, "오류 발생: %s", strerror(errno));
closelog();
```

### ✅ 장점

* 운영환경에서도 안정적
* 로그 파일로 자동 기록 (`/var/log/syslog` 등)
* 로그 레벨 체계적 (info, debug, warning, err)

### ⚠️ 단점

* 단순한 디버깅에는 다소 무거움

---

## ✅ 요약

| 목적             | 추천 방법                                |
| -------------- | ------------------------------------ |
| 간단한 디버깅        | `printf()` 또는 `fprintf(stderr, ...)` |
| 디버깅 출력 제어      | 매크로 (`DBG_PRINT`) 활용                 |
| 운영 환경에서 로그 남기기 | `syslog()`                           |
| 에러 메시지 출력      | `perror()` 또는 `fprintf(stderr, ...)` |

---

필요하시면 로그 레벨별로 출력하는 간단한 `logger` 함수 예시도 드릴 수 있습니다.

# Folly란

좋습니다. "3FS" 파일 시스템을 분석 중이시고, 이 시스템에서 사용하는 **Folly** 라이브러리에 대해 궁금하시군요. 아래에 **Folly**의 기능을 간단하고 실용적으로 정리해드리겠습니다.

---

## ✅ Folly란 무엇인가?

**Folly**는 Facebook(메타)에서 만든 **고성능 C++ 라이브러리 모음**입니다.
**Folly = Facebook Open-source Library**의 줄임말입니다.

* 비동기 처리, 병렬 처리, 메모리 관리, 문자열 처리 등 **고성능 서버 개발을 위한 도구**들이 포함되어 있습니다.
* 주로 Facebook 내부 시스템(예: HHVM, RocksDB, Proxygen)이나 대규모 분산 시스템에서 사용됩니다.
* 모듈형이므로 필요한 부분만 가져와서 사용 가능합니다.

---

## 🎯 Folly의 주요 기능 (3FS에서 사용 가능성이 높은 부분 위주)

| 카테고리        | 주요 기능                                            | 설명                          |
| ----------- | ------------------------------------------------ | --------------------------- |
| **비동기/이벤트** | `folly::Future`, `folly::Promise`                | 비동기 작업 처리 및 콜백 체이닝          |
|             | `folly::EventBase`, `IOThreadPoolExecutor`       | 이벤트 루프, 스레드풀 기반 비동기 처리      |
| **동시성**     | `folly::Synchronized`, `AtomicSharedPtr`         | 멀티스레딩 환경에서 안전한 객체 접근        |
|             | `folly::ProducerConsumerQueue`                   | 고성능 락리스 큐                   |
| **메모리/버퍼**  | `folly::IOBuf`                                   | 고성능 입출력 버퍼, 네트워크 데이터 처리에 적합 |
|             | `Arena`, `SysAllocator`                          | 커스텀 메모리 할당기                 |
| **로깅/디버깅**  | `folly::Logger`, `folly::Format`, `folly::to<>`  | 포맷팅 및 로깅 기능                 |
| **시간/타이머**  | `folly::stop_watch`, `folly::chrono`             | 시간 측정, 타이머 기반 이벤트 처리        |
| **컨테이너**    | `F14Map`, `F14Set`                               | 매우 빠른 해시 맵/셋 구현체            |
| **기타 유틸리티** | `folly::String`, `folly::ScopeGuard`, `Optional` | 문자열 처리, 스코프 종료 처리, 선택적 값    |

---

## 🔍 3FS에서 Folly 사용 예 (가능성 있는 시나리오)

3FS는 대규모 FUSE 기반 사용자 공간 파일 시스템이므로, Folly의 다음 기능들이 유용할 수 있습니다:

* **`folly::IOBuf`**: 고성능 데이터 블록 처리
* **`folly::Future` + `IOThreadPoolExecutor`**: 비동기 I/O 처리
* **`folly::Synchronized`**: 멀티스레딩 동기화
* **`folly::Logger`**: 로깅 출력
* **`F14Map`**: 빠른 해시 기반 메타데이터 저장

---

## 📦 빌드/사용

* 일반적으로 CMake 프로젝트에서 `find_package(folly)`로 사용
* 종속성: Boost 일부, gflags, glog, libevent 등

---

## ✅ 정리

* **Folly는 성능 중심의 C++ 라이브러리로, 대규모 시스템 구현에 필수적인 기능들을 포함**하고 있습니다.
* 특히 3FS처럼 FUSE 기반 사용자 공간 파일 시스템에서는 **비동기 처리, 고성능 버퍼, 멀티스레드 동기화**에 적합합니다.
* C++ 표준보다 고성능이 필요한 영역에서 많이 쓰입니다.

---

필요하시면 `folly::Future` 예제나 `folly::IOBuf`를 사용한 데이터 조작 예제도 알려드릴 수 있습니다.



# withRequestInfo 함수

아래 코드는 FUSE 요청 처리 코드에서 **비동기 코루틴 작업을 동기적으로 실행하면서 요청 정보를 설정**하는 유틸리티 함수입니다.

---

### 🔍 코드 원문

```cpp
template <typename Awaitable>
auto withRequestInfo(fuse_req_t req, Awaitable &&awaitable) {
  auto guard = RequestInfo::set(req);
  return folly::coro::blockingWait(std::forward<Awaitable>(awaitable));
}
```

---

## 📌 주요 구성 요소 설명

| 항목                                   | 설명                                                                                             |
| ------------------------------------ | ---------------------------------------------------------------------------------------------- |
| `template <typename Awaitable>`      | 이 함수는 \*\*코루틴 또는 비동기 객체(Awaitable)\*\*를 인자로 받는 템플릿 함수입니다.                                      |
| `fuse_req_t req`                     | FUSE의 요청 객체. 커널에서 사용자 공간으로 전달된 요청입니다.                                                          |
| `RequestInfo::set(req)`              | 요청 정보를 **TLS(스레드 로컬 저장소)** 또는 컨텍스트에 등록하여, 이후 코드에서 `req`에 접근할 수 있도록 합니다. 아마도 `RAII` 스타일로 처리됩니다. |
| `folly::coro::blockingWait(...)`     | **Folly의 코루틴(Awaitable)을 동기적으로 실행**하고 결과를 반환합니다. 즉, 이 함수는 비동기 코루틴을 기다렸다가 그 결과를 리턴합니다.          |
| `std::forward<Awaitable>(awaitable)` | \*\*완벽 전달(perfect forwarding)\*\*으로 `awaitable`이 왼값(lvalue)인지 오른값(rvalue)인지 보존합니다.             |

---

## ✅ 요약하자면

이 함수는 다음과 같은 일을 합니다:

1. `fuse_req_t` 요청 객체를 `RequestInfo`에 설정하여 현재 스레드나 컨텍스트에서 접근 가능하게 만들고,
2. 전달받은 코루틴(`awaitable`)을 **동기적으로 실행해서 결과를 반환**합니다.

---

## 📘 예시 흐름

```cpp
fuse_req_t req = ...;
auto result = withRequestInfo(req, handleCreateFileAsync(path, flags));
```

* `handleCreateFileAsync(...)`는 비동기 코루틴 함수.
* `withRequestInfo()`는 내부에서 `req`를 TLS에 설정하고,
* 해당 코루틴이 끝날 때까지 기다린 후 결과를 반환합니다.

---

## 🚩 언제 쓰는가?

* FUSE는 기본적으로 동기 API를 제공하지만,
* 내부 로직은 코루틴을 써서 비동기적으로 처리할 수 있음.
* 하지만 FUSE 응답을 보낼 때까지 기다려야 하므로 `blockingWait`으로 기다리는 것.
* 이때 `req` 같은 요청 정보도 필요하므로, 같이 컨텍스트에 넣어주는 구조입니다.

---

## ✅ 결론

`withRequestInfo()`는 FUSE 요청을 처리하는 동안:

* 요청 정보를 TLS에 저장하고,
* 비동기 코드를 동기적으로 실행해서 결과를 반환하는,
* **코루틴과 FUSE를 연결하는 중요한 중간 어댑터 함수**입니다.

필요하시면 `RequestInfo::set()` 구현이나 `folly::coro::Task` 예제도 보여드릴 수 있습니다.


# auto type 사용하는 이유

좋은 질문입니다! `withRequestInfo()` 함수에서 `auto`를 사용하는 이유는 **템플릿으로 받은 `Awaitable`의 반환 타입이 복잡하거나 다양할 수 있기 때문**입니다.

---

## 🔍 다시 보는 함수 정의

```cpp
template <typename Awaitable>
auto withRequestInfo(fuse_req_t req, Awaitable &&awaitable) {
  auto guard = RequestInfo::set(req);
  return folly::coro::blockingWait(std::forward<Awaitable>(awaitable));
}
```

---

## ✅ `auto` 사용 이유

### 1. **`Awaitable`이 반환하는 타입은 다양할 수 있음**

`Awaitable`은 코루틴(Task)일 수도 있고, 미래에 어떤 타입의 값을 반환하는 비동기 작업일 수도 있습니다.

예를 들어:

```cpp
folly::coro::Task<int> foo();      // int를 반환하는 코루틴
folly::coro::Task<std::string> bar(); // string을 반환하는 코루틴
```

위 함수들을 `withRequestInfo()`로 감싸면, 각각 반환 타입이 다릅니다:

```cpp
int x = withRequestInfo(req, foo());
std::string s = withRequestInfo(req, bar());
```

즉, 반환 타입은 `Awaitable`의 실제 타입에 따라 결정되므로 **`auto`로 유연하게 대응**합니다.

---

### 2. **타입 명시가 복잡하거나 장황할 수 있음**

`blockingWait(...)`은 내부적으로 `co_await`를 통해 값의 실제 타입을 반환하는데, 그 타입은 `Awaitable::value_type`, 혹은 `decltype(co_await awaitable)`일 수 있습니다.

직접 명시하면 다음처럼 복잡해질 수 있습니다:

```cpp
std::invoke_result_t<decltype(blockingWait<Awaitable>)>
```

이걸 매번 쓸 수는 없으니, `auto`를 사용해서 간결하게 처리합니다.

---

### 3. **코드 유지보수성과 재사용성 향상**

* 함수에 여러 비동기 작업을 전달할 수 있게 하며,
* 하나의 `withRequestInfo()`로 다양한 반환값을 지원할 수 있게 됩니다.

---

## 📝 참고: `auto`는 반환값의 복사/이동에 따라 의미가 달라질 수 있음

* 복사 비용이 큰 타입이라면, `auto &&` 또는 `decltype(auto)`를 고려할 수도 있습니다.
* 하지만 이 함수에서는 **blockingWait는 일반적으로 값 복사나 이동을 반환**하므로 `auto`만으로 충분합니다.

---

## ✅ 결론

`auto`를 사용한 이유는 다음과 같습니다:

1. `Awaitable`의 결과 타입이 **컴파일 타임에만 결정되는 템플릿 기반이기 때문**
2. 반환 타입이 **복잡하거나 다양해서 추론하는 편이 편리하고 안전하기 때문**
3. 함수 재사용성을 높이고, **코드의 간결성과 유지보수성**을 높이기 때문

필요하시면 `decltype(auto)`와의 차이점도 설명드릴 수 있습니다.


# auto type 선언자

네, 정확하게 이해하셨습니다.
이 코드에서의 `auto`는 **변수의 타입을 컴파일러가 추론하도록 하는 타입 선언자**입니다. 즉, 다음과 같이 해석하시면 됩니다:

---

### ✅ `auto`는 "변수 선언자"로 쓰이는 키워드입니다.

```cpp
auto guard = RequestInfo::set(req);
```

위 코드는 다음과 동일한 의미입니다 (단, 정확한 타입을 명시한다면):

```cpp
RequestInfo::GuardType guard = RequestInfo::set(req); // 예시
```

하지만 `RequestInfo::set(req)`의 반환 타입이 복잡하거나 바뀔 수 있기 때문에, `auto`를 사용하면:

* **타입을 일일이 신경 쓰지 않아도 되고**
* **코드 유지 보수가 쉬워집니다.**

---

### 📘 또 다른 예시: 반환값 추론

```cpp
auto result = someFunction(); // result의 타입은 someFunction()의 반환 타입에 따라 자동 결정됨
```

---

### 📌 요약

| 역할         | 설명                                                        |
| ---------- | --------------------------------------------------------- |
| `auto` 키워드 | 컴파일러가 우변(expression)의 타입을 자동으로 추론해서, 변수 타입으로 지정하는 선언자입니다. |
| 장점         | 코드 간결성, 복잡한 타입 자동 처리, 유지보수 용이성                            |

---

### 🚀 보너스: 함수의 반환 타입에도 사용 가능

C++14부터는 함수의 반환 타입도 `auto`로 선언 가능합니다:

```cpp
auto add(int a, int b) {
    return a + b;
}
```

이 경우 컴파일러가 `int`로 추론합니다.

---

필요하시다면 `decltype(auto)`나 `auto&&`의 차이도 정리해드릴게요.
