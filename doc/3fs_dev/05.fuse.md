# FUSE 개발 

FUSE (Filesystem in Userspace)를 이용해서 사용자 공간에서 파일 시스템을 개발하려면, 다음과 같은 기능들을 구현하고 절차를 따르는 것이 일반적입니다. 아래에서는 Go 언어와 `bazil.org/fuse` 또는 C 언어의 libfuse를 기준으로 설명하겠습니다. Go 기반 예제를 주로 다루되, 필요하시면 C로도 안내드릴 수 있습니다.

---

## 🎯 개발 목표 명확화

먼저 FUSE로 만들고자 하는 파일 시스템의 **목표**를 정합니다. 예를 들어:

* 원격 저장소 연동 (ex. S3, WebDAV)
* 암호화 파일 시스템
* 메타데이터만 제공하는 파일 시스템
* 캐시 기반 파일 시스템
* 데이터 중복 제거/가시화용 파일 시스템

---

## 🧱 주요 기능 목록 (핵심 FUSE 연동 함수들)

| 기능          | 설명                      | 대응 FUSE 메서드                    |
| ----------- | ----------------------- | ------------------------------ |
| 마운트         | 파일 시스템을 mount 지점에 연결    | `fuse.Mount()`                 |
| 파일/디렉토리 열람  | `ls`, `stat` 등을 지원      | `Attr`, `Lookup`, `ReadDirAll` |
| 파일 열기/읽기/쓰기 | `open`, `read`, `write` | `Open`, `Read`, `Write`        |
| 파일 생성/삭제    | `touch`, `rm`           | `Create`, `Remove`             |
| 디렉토리 생성/삭제  | `mkdir`, `rmdir`        | `Mkdir`, `Rmdir`               |
| 심볼릭 링크/하드링크 | 링크 기능                   | `Symlink`, `Link`              |
| 파일 시스템 언마운트 | 종료 처리                   | 신호 핸들링 또는 `fusermount -u`      |

---

## 🧭 개발 절차 (Go 기준)

### 1. 프로젝트 초기화 및 FUSE 라이브러리 설치

```bash
go mod init myfs
go get bazil.org/fuse
go get bazil.org/fuse/fs
```

---

### 2. 기본 구조 정의

```go
type FS struct{}
func (FS) Root() (fs.Node, error) { return &Dir{}, nil }

type Dir struct{}
func (d *Dir) Attr(ctx context.Context, a *fuse.Attr) error {
    a.Inode = 1
    a.Mode = os.ModeDir | 0555
    return nil
}
```

---

### 3. 디렉토리 탐색 구현 (`ReadDirAll`)

```go
func (d *Dir) ReadDirAll(ctx context.Context) ([]fuse.Dirent, error) {
    return []fuse.Dirent{
        {Inode: 2, Name: "hello.txt", Type: fuse.DT_File},
    }, nil
}
```

---

### 4. 파일 탐색 (`Lookup`) 및 읽기 구현

```go
func (d *Dir) Lookup(ctx context.Context, name string) (fs.Node, error) {
    if name == "hello.txt" {
        return &File{}, nil
    }
    return nil, fuse.ENOENT
}

type File struct{}
func (f *File) Attr(ctx context.Context, a *fuse.Attr) error {
    a.Inode = 2
    a.Mode = 0444
    a.Size = uint64(len("Hello, world!\n"))
    return nil
}
func (f *File) ReadAll(ctx context.Context) ([]byte, error) {
    return []byte("Hello, world!\n"), nil
}
```

---

### 5. 마운트 처리 및 메인 함수

```go
func main() {
    c, err := fuse.Mount(
        "./mnt",
        fuse.FSName("myfs"),
        fuse.Subtype("memfs"),
        fuse.LocalVolume(),
        fuse.VolumeName("MyFuseFS"),
    )
    if err != nil {
        log.Fatal(err)
    }
    defer c.Close()
    if err := fs.Serve(c, FS{}); err != nil {
        log.Fatal(err)
    }
}
```

---

## 🔐 권장 개발 순서 요약

1. ✅ 마운트 구현 및 `main()` 함수 정리
2. ✅ 디렉토리 탐색 (`ReadDirAll`, `Attr`) 구현
3. ✅ 파일 읽기 (`Read`, `ReadAll`) 구현
4. ➕ 파일 생성/쓰기 (`Create`, `Write`) 기능 확장
5. ➕ 삭제, 링크, 시간 정보 등 부가기능
6. 🧪 `fusermount -u ./mnt` 으로 테스트 마무리

---

## 🛠️ 디버깅 및 테스트 팁

* `strace`를 활용해 syscall 흐름 확인
* `ll ./mnt`로 inode 응답 점검
* `/var/log/syslog` 확인 (Linux 환경)

---

## 💡 실제 적용 예시 아이디어

* `DedupFS`: 파일 중복을 실시간으로 감지해 링크 처리
* `MetaFS`: 파일 이름과 메타데이터만 제공, 실제 데이터는 미제공
* `CloudFS`: S3 같은 원격 저장소의 객체를 로컬 파일처럼 마운트
* `MonitorFS`: 파일 접근 시 로그를 수집해 보안 감시용으로 사용

---

필요하시면 다음 주제를 자세히 도와드릴 수 있습니다:

* S3 기반 FUSE 파일 시스템 설계
* FUSE의 메타데이터 성능 최적화
* libfuse (C 기반) 코드 샘플
* eBPF 기반 추적 연동

어떤 목적의 FUSE 파일 시스템을 개발하시는지 알려주시면, 더 구체적으로 설계 도와드릴 수 있습니다.


# libfuse 기반 샘플코드

libfuse를 기반으로 한 FUSE 파일 시스템의 가장 단순한 샘플 코드를 아래에 제공합니다. 이 예제는 단순히 `/hello`라는 가상의 파일을 제공하며, 그 파일을 `cat` 하면 `"Hello, World!\n"`을 반환합니다.

---

## ✅ libfuse 기본 샘플 (C 언어)

```c
#define FUSE_USE_VERSION 31

#include <fuse3/fuse.h>
#include <string.h>
#include <errno.h>

static const char *hello_path = "/hello";
static const char *hello_str = "Hello, World!\n";

// getattr: 파일 속성 반환
static int hello_getattr(const char *path, struct stat *stbuf,
                         struct fuse_file_info *fi)
{
    (void) fi;
    memset(stbuf, 0, sizeof(struct stat));

    if (strcmp(path, "/") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path, hello_path) == 0) {
        stbuf->st_mode = S_IFREG | 0444;
        stbuf->st_nlink = 1;
        stbuf->st_size = strlen(hello_str);
    } else {
        return -ENOENT;
    }
    return 0;
}

// readdir: 디렉토리 나열
static int hello_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                         off_t offset, struct fuse_file_info *fi,
                         enum fuse_readdir_flags flags)
{
    (void) offset;
    (void) fi;
    (void) flags;

    if (strcmp(path, "/") != 0)
        return -ENOENT;

    filler(buf, ".", NULL, 0, 0);
    filler(buf, "..", NULL, 0, 0);
    filler(buf, "hello", NULL, 0, 0);

    return 0;
}

// open: 파일 열기
static int hello_open(const char *path, struct fuse_file_info *fi)
{
    if (strcmp(path, hello_path) != 0)
        return -ENOENT;

    if ((fi->flags & O_ACCMODE) != O_RDONLY)
        return -EACCES;

    return 0;
}

// read: 파일 읽기
static int hello_read(const char *path, char *buf, size_t size, off_t offset,
                      struct fuse_file_info *fi)
{
    size_t len;
    (void) fi;

    if (strcmp(path, hello_path) != 0)
        return -ENOENT;

    len = strlen(hello_str);
    if (offset < len) {
        if (offset + size > len)
            size = len - offset;
        memcpy(buf, hello_str + offset, size);
    } else
        size = 0;

    return size;
}

// FUSE 연동 함수 구조체
static struct fuse_operations hello_ops = {
    .getattr = hello_getattr,
    .readdir = hello_readdir,
    .open    = hello_open,
    .read    = hello_read,
};

// main 함수
int main(int argc, char *argv[])
{
    return fuse_main(argc, argv, &hello_ops, NULL);
}
```

---

## 🔧 빌드 방법 (Ubuntu 기준)

1. **libfuse 설치** (fuse3 기준):

   ```bash
   sudo apt update
   sudo apt install libfuse3-dev
   ```

2. **컴파일**:

   ```bash
   gcc -Wall hello.c -o hello `pkg-config fuse3 --cflags --libs`
   ```

3. **마운트 디렉터리 생성**:

   ```bash
   mkdir mnt
   ```

4. **마운트 실행 (포그라운드)**:

   ```bash
   ./hello mnt
   ```

5. **테스트**:

   ```bash
   ls mnt
   cat mnt/hello
   ```

6. **언마운트**:

   ```bash
   fusermount3 -u mnt
   ```

---

## 📌 주요 포인트 요약

* `/hello` 라는 가상 파일을 노출
* `getattr`, `readdir`, `open`, `read` 등 FUSE 콜백 함수 등록
* `fuse_main()`을 통해 이벤트 루프 실행
* 읽기 전용, 쓰기 미지원

---

## 📚 다음 단계로 확장하려면?

* `write()`, `create()` 구현하여 쓰기 가능하게 만들기
* 파일 내용을 메모리나 디스크 기반으로 관리
* 특정 디렉토리 트리 전체를 감싸는 FUSE proxy 만들기
* 원격 파일 시스템(S3, WebDAV 등) 연동

---

필요하시다면 다음 주제로 이어드릴 수 있습니다:

* `write`, `create`, `unlink` 추가 구현
* 실제 파일 시스템을 메모리 상에 유지하는 RAMFS 구현
* 로그 수집형 FUSE 파일 시스템 설계

원하시는 방향 있으시면 알려주세요.


# FUSE posix api 처리 절차

POSIX 애플리케이션이 `open()`, `read()`, `write()`, `close()` 등의 시스템 호출을 통해 파일을 생성하고 읽기 작업을 수행할 때, **FUSE 파일 시스템이 처리에 어떻게 관여하고**, **어떤 함수와 라이브러리 레벨에서 호출 흐름이 일어나는지**를 단계별로 설명드리겠습니다.

---

## 📌 전제 조건

* **Application**: 일반 Linux 사용자 프로그램 (C 등으로 작성됨)
* **파일 경로**: FUSE로 마운트된 디렉터리 아래 예: `/mnt/myfuse/hello.txt`
* **FUSE**: libfuse 또는 bazil.org/fuse 사용
* **커널 FUSE 모듈**: `fuse.ko` (Kernel space driver)
* **유저 공간 FUSE 데몬**: `hello_fs` (사용자 정의 FUSE 프로그램)

---

## ✅ 처리 절차 흐름 (예: 파일 생성 후 읽기)

### 1. **`open("mnt/hello.txt", O_CREAT|O_RDWR)` 호출**

#### 📌 POSIX → 커널 흐름

| 단계 | 설명                                  | 호출                |
| -- | ----------------------------------- | ----------------- |
| 1  | 애플리케이션이 POSIX API 호출                | `open()`          |
| 2  | glibc가 syscall 래퍼를 통해 커널로 전달        | `sys_openat()`    |
| 3  | 커널 VFS가 해당 경로의 파일 시스템을 찾음           | VFS 레벨            |
| 4  | `/mnt`가 FUSE 마운트임을 인식               | FUSE FS 타입        |
| 5  | 커널 FUSE 모듈이 사용자 공간 FUSE 프로세스에 요청 전달 | `/dev/fuse` 통해 전달 |

#### 📌 FUSE 데몬 처리 (유저 공간)

| 단계 | 설명                          | 관련 함수                   |
| -- | --------------------------- | ----------------------- |
| 6  | FUSE 데몬이 open/create 요청을 읽음 | `Create()` 또는 `Open()`  |
| 7  | 요청 처리 후 응답                  | `fuse_reply_create()` 등 |
| 8  | 커널이 파일 디스크립터를 생성            | `fd` 반환                 |

---

### 2. **`write(fd, "hello", 5)` 호출**

| 단계 | 설명                                | 호출                            |
| -- | --------------------------------- | ----------------------------- |
| 1  | 사용자 앱이 POSIX `write()` 호출         | `write()`                     |
| 2  | glibc → syscall → 커널              | `sys_write()`                 |
| 3  | 커널 FUSE 모듈이 write 요청을 FUSE 데몬에 전달 | FUSE write request            |
| 4  | FUSE 데몬이 `Write()` 핸들러에서 처리       | libfuse: `write()` / fuse\_op |
| 5  | 결과 처리 후 응답                        | `fuse_reply_write()`          |

---

### 3. **`read(fd, buf, size)` 호출**

| 단계 | 설명                       | 호출                 |
| -- | ------------------------ | ------------------ |
| 1  | 앱이 POSIX `read()` 호출     | `read()`           |
| 2  | glibc → syscall → 커널     | `sys_read()`       |
| 3  | 커널이 FUSE 요청으로 전환         | FUSE read request  |
| 4  | FUSE 데몬의 `Read()` 핸들러 호출 | libfuse의 `read()`  |
| 5  | 읽은 데이터 사용자에게 반환          | `fuse_reply_buf()` |

---

### 4. **`close(fd)` 호출**

| 단계 | 설명                       | 호출          |
| -- | ------------------------ | ----------- |
| 1  | 애플리케이션이 `close()` 호출     | `close()`   |
| 2  | glibc → `sys_close()`    | 커널 syscall  |
| 3  | 커널이 FUSE `release()` 호출  | FUSE FS에 통보 |
| 4  | FUSE 데몬에서 `Release()` 처리 | 자원 해제       |

---

## 📦 구성요소 별 요약

| 구성 요소                           | 동작                                        |
| ------------------------------- | ----------------------------------------- |
| **glibc**                       | 사용자 애플리케이션과 커널 사이에서 POSIX 함수 ↔ syscall 매핑 |
| **Linux Kernel (VFS)**          | 경로 파싱, 파일 시스템 호출 추상화                      |
| **FUSE 커널 모듈**                  | `/dev/fuse` 통해 사용자 공간 데몬과 메시지 송수신         |
| **libfuse (또는 bazil.org/fuse)** | 유저 공간에서 요청 수신/응답                          |
| **FUSE 데몬 프로세스**                | 파일 시스템 로직 직접 구현 (Open/Read/Write/Attr 등)  |

---

## 🖼️ 그림으로 요약

```
Application
  └── open("/mnt/hello", O_CREAT)
        ↓ (glibc)
    syscall → sys_openat()
        ↓
    Kernel VFS
        ↓
    FUSE 커널 모듈
        ↓
    /dev/fuse ↔ 사용자 공간 FUSE 데몬
        ↓
    FUSE handler: Create(), Open(), Write(), Read() 등
```

---

## 💡 추가 팁

* `strace` 명령어를 통해 애플리케이션의 실제 syscall 흐름을 확인할 수 있습니다:

  ```bash
  strace -f -e trace=open,read,write ./your_app
  ```

* FUSE 데몬에서는 `fuse_lowlevel.h` 또는 `fuse.h`의 콜백 함수를 구현해야 합니다.

  * libfuse 3.x 기준: `fuse_operations` 구조체를 채우는 방식

---

필요하시면 `strace`나 `fuse_lowlevel` API 수준 예제, 또는 syscall ↔ FUSE message 포맷을 더 자세히 설명드릴 수 있습니다.



# FUSE POSIX API

좋은 질문입니다.
FUSE(Filesystem in Userspace)는 **커널의 VFS 계층이 POSIX API를 통해 발생한 파일 시스템 호출을 사용자 공간에 위임하는 메커니즘**입니다.
FUSE 어플리케이션(사용자 공간 파일 시스템 구현체)은 **커널로부터 요청을 받아 처리하고**, 그 결과를 다시 커널에 응답합니다.

아래에 FUSE 어플리케이션이 **POSIX API 호출을 인식하고, 처리 결과를 커널(FUSE 모듈)에 돌려주는 구조**를 단계별로 설명드리겠습니다.

---

## ✅ 1. POSIX API 호출 흐름 (예: `open()`, `read()` 등)

1. 사용자 애플리케이션이 POSIX API 호출 (예: `open("/mnt/myfuse/file.txt")`)
2. 커널의 VFS 계층은 해당 경로가 FUSE로 마운트된 파일 시스템임을 인식
3. 커널은 FUSE 커널 모듈을 통해 `/dev/fuse`에 요청 메시지를 생성 (예: `FUSE_OPEN`, `FUSE_READ`)
4. FUSE 어플리케이션은 `/dev/fuse`를 통해 이 메시지를 읽어 들임
5. 메시지를 처리한 후, 그 결과를 다시 `/dev/fuse`로 쓰면서 응답
6. 커널은 응답을 수신하고 POSIX API 호출의 결과로 사용자 애플리케이션에 전달

---

## ✅ 2. FUSE 어플리케이션 내부 구조

FUSE 라이브러리(libfuse 또는 bazil.org/fuse)를 사용하면, 아래와 같은 방식으로 POSIX API 호출을 **콜백 함수**로 처리할 수 있습니다.

### 예시: libfuse 기반 코드

```c
#include <fuse3/fuse.h>
#include <stdio.h>
#include <string.h>

static int my_getattr(const char *path, struct stat *stbuf, struct fuse_file_info *fi) {
    memset(stbuf, 0, sizeof(struct stat));
    if (strcmp(path, "/hello.txt") == 0) {
        stbuf->st_mode = S_IFREG | 0444;
        stbuf->st_nlink = 1;
        stbuf->st_size = 12;
        return 0;
    }
    return -ENOENT;
}

static int my_open(const char *path, struct fuse_file_info *fi) {
    if (strcmp(path, "/hello.txt") != 0)
        return -ENOENT;
    return 0;  // 성공
}

static int my_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    const char *contents = "Hello World\n";
    size_t len = strlen(contents);
    if (offset < len) {
        if (offset + size > len)
            size = len - offset;
        memcpy(buf, contents + offset, size);
    } else {
        size = 0;
    }
    return size;
}

static struct fuse_operations my_oper = {
    .getattr = my_getattr,
    .open    = my_open,
    .read    = my_read,
};

int main(int argc, char *argv[]) {
    return fuse_main(argc, argv, &my_oper, NULL);
}
```

### 흐름 요약

| POSIX 호출         | FUSE 콜백     |
| ---------------- | ----------- |
| `stat()` 또는 `ls` | `getattr()` |
| `open()`         | `open()`    |
| `read()`         | `read()`    |
| `write()`        | `write()`   |
| `unlink()`       | `unlink()`  |
| ...              | ...         |

---

## ✅ 3. 처리 결과를 FUSE 커널 모듈에 전달하는 방식

FUSE 라이브러리는 내부적으로 `/dev/fuse`에 응답을 작성하여 커널에 전달합니다.

```c
// 예: read 요청 처리 후
return size; // fuse 라이브러리가 fuse_reply_buf() 등을 내부적으로 호출
```

libfuse는 실제 응답을 다음과 같이 내부적으로 처리합니다 (단순화된 형태):

```c
fuse_reply_buf(req, buf, size); // 응답을 커널에 전달
```

사용자는 `return size;`만 하면 되고, libfuse가 실제로는 `write(fd, response, len)` 형태로 `/dev/fuse`에 응답을 씁니다.

---

## ✅ 전체 흐름 정리 (도식)

```
[Application]
  └─ open("/mnt/myfuse/hello.txt")
       ↓
[glibc → syscall → Kernel VFS]
       ↓
[FUSE 커널 모듈]
       ↓
[전송: /dev/fuse → 사용자 공간]
       ↓
[libfuse 또는 사용자 프로그램]
       ├─ .open() 호출
       ├─ .read() 호출
       └─ .getattr() 호출
       ↓
[응답: write() → /dev/fuse]
       ↓
[커널 VFS → 사용자에게 결과 전달]
```

---

## ✅ 요약

| 구성 요소                               | 역할                                   |
| ----------------------------------- | ------------------------------------ |
| POSIX API (`open`, `read`, `write`) | 사용자가 호출하는 시스템 인터페이스                  |
| 커널 VFS + FUSE 모듈                    | FUSE 파일 시스템인 경우 요청을 `/dev/fuse`로 전달  |
| FUSE 어플리케이션                         | 요청을 읽고(libfuse가 추상화), 콜백 함수로 처리      |
| libfuse                             | `/dev/fuse` I/O를 처리하고 콜백 함수 호출/응답 전달 |
| 응답                                  | `fuse_reply_*()` 또는 함수 반환으로 응답       |

---

원하시면 `write()`나 `mkdir()`, `readdir()` 같은 다른 콜백 함수 예시나, 직접 fuse\_lowlevel API 사용하는 예시도 드릴 수 있습니다.
